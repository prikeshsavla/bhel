var e = Object.defineProperty,t = ("undefined" != typeof require && require, (t, n, s) => (((t, n, s) => {n in t ? e(t, n, { enumerable: !0, configurable: !0, writable: !0, value: s }) : t[n] = s;})(t, "symbol" != typeof n ? n + "" : n, s), s));function n(e, t) {const n = Object.create(null),s = e.split(",");for (let r = 0; r < s.length; r++) n[s[r]] = !0;return t ? e => !!n[e.toLowerCase()] : e => !!n[e];}function s(e) {if (p(e)) {const t = {};for (let n = 0; n < e.length; n++) {const r = e[n],i = g(r) ? o(r) : s(r);if (i) for (const e in i) t[e] = i[e];}return t;}return g(e) || y(e) ? e : void 0;}const r = /;(?![^(]*\))/g,i = /:(.+)/;function o(e) {const t = {};return e.split(r).forEach(e => {if (e) {const n = e.split(i);n.length > 1 && (t[n[0].trim()] = n[1].trim());}}), t;}function c(e) {let t = "";if (g(e)) t = e;else if (p(e)) for (let n = 0; n < e.length; n++) {const s = c(e[n]);s && (t += s + " ");} else if (y(e)) for (const n in e) e[n] && (t += n + " ");return t.trim();}function l(e, t) {if (e === t) return !0;let n = m(e),s = m(t);if (n || s) return !(!n || !s) && e.getTime() === t.getTime();if (n = p(e), s = p(t), n || s) return !(!n || !s) && function (e, t) {if (e.length !== t.length) return !1;let n = !0;for (let s = 0; n && s < e.length; s++) n = l(e[s], t[s]);return n;}(e, t);if (n = y(e), s = y(t), n || s) {if (!n || !s) return !1;if (Object.keys(e).length !== Object.keys(t).length) return !1;for (const n in e) {const s = e.hasOwnProperty(n),r = t.hasOwnProperty(n);if (s && !r || !s && r || !l(e[n], t[n])) return !1;}}return String(e) === String(t);}function f(e, t) {return e.findIndex(e => l(e, t));}const u = Object.assign,a = Object.prototype.hasOwnProperty,h = (e, t) => a.call(e, t),p = Array.isArray,d = e => "[object Map]" === x(e),m = e => e instanceof Date,g = e => "string" == typeof e,v = e => "symbol" == typeof e,y = e => null !== e && "object" == typeof e,b = Object.prototype.toString,x = e => b.call(e),w = e => g(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,_ = e => {const t = Object.create(null);return n => t[n] || (t[n] = e(n));},$ = /-(\w)/g,k = _(e => e.replace($, (e, t) => t ? t.toUpperCase() : "")),O = /\B([A-Z])/g,S = _(e => e.replace(O, "-$1").toLowerCase()),E = e => {const t = parseFloat(e);return isNaN(t) ? e : t;};function j(e, t) {(t = t || undefined) && t.active && t.effects.push(e);}const A = e => {const t = new Set(e);return t.w = 0, t.n = 0, t;},R = e => (e.w & T) > 0,C = e => (e.n & T) > 0,P = new WeakMap();let N = 0,T = 1;const M = [];let B;const L = Symbol(""),W = Symbol("");class I {constructor(e, t = null, n) {this.fn = e, this.scheduler = t, this.active = !0, this.deps = [], j(this, n);}run() {if (!this.active) return this.fn();if (!M.includes(this)) try {return M.push(B = this), q.push(V), V = !0, T = 1 << ++N, N <= 30 ? (({ deps: e }) => {if (e.length) for (let t = 0; t < e.length; t++) e[t].w |= T;})(this) : K(this), this.fn();} finally {N <= 30 && (e => {const { deps: t } = e;if (t.length) {let n = 0;for (let s = 0; s < t.length; s++) {const r = t[s];R(r) && !C(r) ? r.delete(e) : t[n++] = r, r.w &= ~T, r.n &= ~T;}t.length = n;}})(this), T = 1 << --N, z(), M.pop();const e = M.length;B = e > 0 ? M[e - 1] : void 0;}}stop() {this.active && (K(this), this.onStop && this.onStop(), this.active = !1);}}function K(e) {const { deps: t } = e;if (t.length) {for (let n = 0; n < t.length; n++) t[n].delete(e);t.length = 0;}}function F(e) {e.effect.stop();}let V = !0;const q = [];function z() {const e = q.pop();V = void 0 === e || e;}function H(e, t, n) {if (!V || void 0 === B) return;let s = P.get(e);s || P.set(e, s = new Map());let r = s.get(n);r || s.set(n, r = A()), function (e, t) {let n = !1;N <= 30 ? C(e) || (e.n |= T, n = !R(e)) : n = !e.has(B);n && (e.add(B), B.deps.push(e));}(r);}function J(e, t, n, s, r, i) {const o = P.get(e);if (!o) return;let c = [];if ("clear" === t) c = [...o.values()];else if ("length" === n && p(e)) o.forEach((e, t) => {("length" === t || t >= s) && c.push(e);});else switch (void 0 !== n && c.push(o.get(n)), t) {case "add":p(e) ? w(n) && c.push(o.get("length")) : (c.push(o.get(L)), d(e) && c.push(o.get(W)));break;case "delete":p(e) || (c.push(o.get(L)), d(e) && c.push(o.get(W)));break;case "set":d(e) && c.push(o.get(L));}if (1 === c.length) c[0] && Z(c[0]);else {const e = [];for (const t of c) t && e.push(...t);Z(A(e));}}function Z(e, t) {for (const n of p(e) ? e : [...e]) (n !== B || n.allowRecurse) && (n.scheduler ? n.scheduler() : n.run());}const D = n("__proto__,__v_isRef,__isVue"),G = new Set(Object.getOwnPropertyNames(Symbol).map(e => Symbol[e]).filter(v)),U = ee(),Q = ee(!0),X = Y();function Y() {const e = {};return ["includes", "indexOf", "lastIndexOf"].forEach(t => {e[t] = function (...e) {const n = ae(this);for (let t = 0, r = this.length; t < r; t++) H(n, 0, t + "");const s = n[t](...e);return -1 === s || !1 === s ? n[t](...e.map(ae)) : s;};}), ["push", "pop", "shift", "unshift", "splice"].forEach(t => {e[t] = function (...e) {q.push(V), V = !1;const n = ae(this)[t].apply(this, e);return z(), n;};}), e;}function ee(e = !1, t = !1) {return function (n, s, r) {if ("__v_isReactive" === s) return !e;if ("__v_isReadonly" === s) return e;if ("__v_raw" === s && r === (e ? t ? ce : oe : t ? ie : re).get(n)) return n;const i = p(n);if (!e && i && h(X, s)) return Reflect.get(X, s, r);const o = Reflect.get(n, s, r);if (v(s) ? G.has(s) : D(s)) return o;if (e || H(n, 0, s), t) return o;if (he(o)) {return !i || !w(s) ? o.value : o;}return y(o) ? e ? function (e) {return ue(e, !0, se, null, oe);}(o) : fe(o) : o;};}function te(e = !1) {return function (t, n, s, r) {let i = t[n];if (!e && (s = ae(s), i = ae(i), !p(t) && he(i) && !he(s))) return i.value = s, !0;const o = p(t) && w(n) ? Number(n) < t.length : h(t, n),c = Reflect.set(t, n, s, r);return t === ae(r) && (o ? ((e, t) => !Object.is(e, t))(s, i) && J(t, "set", n, s) : J(t, "add", n, s)), c;};}const ne = { get: U, set: te(), deleteProperty: function (e, t) {const n = h(e, t);e[t];const s = Reflect.deleteProperty(e, t);return s && n && J(e, "delete", t, void 0), s;}, has: function (e, t) {const n = Reflect.has(e, t);return v(t) && G.has(t) || H(e, 0, t), n;}, ownKeys: function (e) {return H(e, 0, p(e) ? "length" : L), Reflect.ownKeys(e);} },se = { get: Q, set: (e, t) => !0, deleteProperty: (e, t) => !0 },re = new WeakMap(),ie = new WeakMap(),oe = new WeakMap(),ce = new WeakMap();function le(e) {return e.__v_skip || !Object.isExtensible(e) ? 0 : function (e) {switch (e) {case "Object":case "Array":return 1;case "Map":case "Set":case "WeakMap":case "WeakSet":return 2;default:return 0;}}((e => x(e).slice(8, -1))(e));}function fe(e) {return e && e.__v_isReadonly ? e : ue(e, !1, ne, null, re);}function ue(e, t, n, s, r) {if (!y(e)) return e;if (e.__v_raw && (!t || !e.__v_isReactive)) return e;const i = r.get(e);if (i) return i;const o = le(e);if (0 === o) return e;const c = new Proxy(e, 2 === o ? s : n);return r.set(e, c), c;}function ae(e) {const t = e && e.__v_raw;return t ? ae(t) : e;}function he(e) {return Boolean(e && !0 === e.__v_isRef);}Promise.resolve();let pe = !1;const de = [],me = Promise.resolve(),ge = e => me.then(e),ve = e => {de.includes(e) || de.push(e), pe || (pe = !0, ge(ye));},ye = () => {for (const e of de) e();de.length = 0, pe = !1;},be = /^(spellcheck|draggable|form|list|type)$/,xe = ({ el: e, get: t, effect: n, arg: s, modifiers: r }) => {let i;"class" === s && (e._class = e.className), n(() => {let n = t();if (s) (null == r ? void 0 : r.camel) && (s = k(s)), we(e, s, n, i);else {for (const t in n) we(e, t, n[t], i && i[t]);for (const t in i) n && t in n || we(e, t, null);}i = n;});},we = (e, t, n, r) => {if ("class" === t) e.setAttribute("class", c(e._class ? [e._class, n] : n) || "");else if ("style" === t) {n = s(n);const { style: t } = e;if (n) {if (g(n)) n !== r && (t.cssText = n);else {for (const e in n) $e(t, e, n[e]);if (r && !g(r)) for (const e in r) null == n[e] && $e(t, e, "");}} else e.removeAttribute("style");} else e instanceof SVGElement || !(t in e) || be.test(t) ? "true-value" === t ? e._trueValue = n : "false-value" === t ? e._falseValue = n : null != n ? e.setAttribute(t, n) : e.removeAttribute(t) : (e[t] = n, "value" === t && (e._value = n));},_e = /\s*!important$/,$e = (e, t, n) => {p(n) ? n.forEach(n => $e(e, t, n)) : t.startsWith("--") ? e.setProperty(t, n) : _e.test(n) ? e.setProperty(S(t), n.replace(_e, ""), "important") : e[t] = n;},ke = (e, t) => {const n = e.getAttribute(t);return null != n && e.removeAttribute(t), n;},Oe = (e, t, n, s) => {e.addEventListener(t, n, s);},Se = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Ee = ["ctrl", "shift", "alt", "meta"],je = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && 0 !== e.button, middle: e => "button" in e && 1 !== e.button, right: e => "button" in e && 2 !== e.button, exact: (e, t) => Ee.some(n => e[`${n}Key`] && !t[n]) },Ae = ({ el: e, get: t, exp: n, arg: s, modifiers: r }) => {if (!s) return;let i = Se.test(n) ? t(`(e => ${n}(e))`) : t(`($event => { ${n} })`);if ("mounted" !== s) {if ("unmounted" === s) return () => i();if (r) {"click" === s && (r.right && (s = "contextmenu"), r.middle && (s = "mouseup"));const e = i;i = t => {if (!("key" in t) || S(t.key) in r) {for (const e in r) {const n = je[e];if (n && n(t, r)) return;}return e(t);}};}Oe(e, s, i, r);} else ge(i);},Re = ({ el: e, get: t, effect: n }) => {n(() => {e.textContent = Ce(t());});},Ce = e => null == e ? "" : y(e) ? JSON.stringify(e, null, 2) : String(e),Pe = e => "_value" in e ? e._value : e.value,Ne = (e, t) => {const n = t ? "_trueValue" : "_falseValue";return n in e ? e[n] : t;},Te = e => {e.target.composing = !0;},Me = e => {const t = e.target;t.composing && (t.composing = !1, Be(t, "input"));},Be = (e, t) => {const n = document.createEvent("HTMLEvents");n.initEvent(t, !0, !0), e.dispatchEvent(n);},Le = Object.create(null),We = (e, t, n) => Ie(e, `return(${t})`, n),Ie = (e, t, n) => {const s = Le[t] || (Le[t] = Ke(t));try {return s(e, n);} catch (r) {console.error(r);}},Ke = e => {try {return new Function("$data", "$el", `with($data){${e}}`);} catch (t) {return console.error(`${t.message} in expression: ${e}`), () => {};}},Fe = { bind: xe, on: Ae, show: ({ el: e, get: t, effect: n }) => {const s = e.style.display;n(() => {e.style.display = t() ? s : "none";});}, text: Re, html: ({ el: e, get: t, effect: n }) => {n(() => {e.innerHTML = t();});}, model: ({ el: e, exp: t, get: n, effect: s, modifiers: r }) => {const i = e.type,o = n(`(val) => { ${t} = val }`),{ trim: c, number: u = "number" === i } = r || {};if ("SELECT" === e.tagName) {const t = e;Oe(e, "change", () => {const e = Array.prototype.filter.call(t.options, e => e.selected).map(e => u ? E(Pe(e)) : Pe(e));o(t.multiple ? e : e[0]);}), s(() => {const e = n(),s = t.multiple;for (let n = 0, r = t.options.length; n < r; n++) {const r = t.options[n],i = Pe(r);if (s) p(e) ? r.selected = f(e, i) > -1 : r.selected = e.has(i);else if (l(Pe(r), e)) return void (t.selectedIndex !== n && (t.selectedIndex = n));}s || -1 === t.selectedIndex || (t.selectedIndex = -1);});} else if ("checkbox" === i) {let t;Oe(e, "change", () => {const t = n(),s = e.checked;if (p(t)) {const n = Pe(e),r = f(t, n),i = -1 !== r;if (s && !i) o(t.concat(n));else if (!s && i) {const e = [...t];e.splice(r, 1), o(e);}} else o(Ne(e, s));}), s(() => {const s = n();p(s) ? e.checked = f(s, Pe(e)) > -1 : s !== t && (e.checked = l(s, Ne(e, !0))), t = s;});} else if ("radio" === i) {let t;Oe(e, "change", () => {o(Pe(e));}), s(() => {const s = n();s !== t && (e.checked = l(s, Pe(e)));});} else {const t = e => c ? e.trim() : u ? E(e) : e;Oe(e, "compositionstart", Te), Oe(e, "compositionend", Me), Oe(e, (null == r ? void 0 : r.lazy) ? "change" : "input", () => {e.composing || o(t(e.value));}), c && Oe(e, "change", () => {e.value = e.value.trim();}), s(() => {if (e.composing) return;const s = e.value,r = n();document.activeElement === e && t(s) === r || s !== r && (e.value = r);});}}, effect: ({ el: e, ctx: t, exp: n, effect: s }) => {ge(() => s(() => Ie(t.scope, n, e)));} },Ve = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,qe = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,ze = /^\(|\)$/g,He = /^[{[]\s*((?:[\w_$]+\s*,?\s*)+)[\]}]$/,Je = (e, t, n) => {const s = t.match(Ve);if (!s) return;const r = e.nextSibling,i = e.parentElement,o = new Text("");i.insertBefore(o, e), i.removeChild(e);const c = s[2].trim();let l,f,u,a,h = s[1].trim().replace(ze, "").trim(),d = !1,m = "key",g = e.getAttribute(m) || e.getAttribute(m = ":key") || e.getAttribute(m = "v-bind:key");g && (e.removeAttribute(m), "key" === m && (g = JSON.stringify(g))), (a = h.match(qe)) && (h = h.replace(qe, "").trim(), f = a[1].trim(), a[2] && (u = a[2].trim())), (a = h.match(He)) && (l = a[1].split(",").map(e => e.trim()), d = "[" === h[0]);let v,b,x,w = !1;const _ = (e, t, s, r) => {const i = {};l ? l.forEach((e, n) => i[e] = t[d ? n : e]) : i[h] = t, r ? (f && (i[f] = r), u && (i[u] = s)) : f && (i[f] = s);const o = st(n, i),c = g ? We(o.scope, g) : s;return e.set(c, s), o.key = c, o;},$ = (t, n) => {const s = new it(e, t);return s.key = t.key, s.insert(i, n), s;};return n.effect(() => {const e = We(n.scope, c),t = x;if ([b, x] = (e => {const t = new Map(),n = [];if (p(e)) for (let s = 0; s < e.length; s++) n.push(_(t, e[s], s));else if ("number" == typeof e) for (let s = 0; s < e; s++) n.push(_(t, s + 1, s));else if (y(e)) {let s = 0;for (const r in e) n.push(_(t, e[r], s++, r));}return [n, t];})(e), w) {for (let t = 0; t < v.length; t++) x.has(v[t].key) || v[t].remove();const e = [];let n,s,r = b.length;for (; r--;) {const c = b[r],l = t.get(c.key);let f;null == l ? f = $(c, n ? n.el : o) : (f = v[l], Object.assign(f.ctx.scope, c.scope), l !== r && (v[l + 1] === n && s !== n || (s = f, f.insert(i, n ? n.el : o)))), e.unshift(n = f);}v = e;} else v = b.map(e => $(e, o)), w = !0;}), r;},Ze = ({ el: e, ctx: { scope: { $refs: t } }, get: n, effect: s }) => {let r;return s(() => {const s = n();t[s] = e, r && s !== r && delete t[r], r = s;}), () => {r && delete t[r];};},De = /^(?:v-|:|@)/,Ge = /\.([\w-]+)/g;let Ue = !1;const Qe = (e, t) => {const n = e.nodeType;if (1 === n) {const n = e;if (n.hasAttribute("v-pre")) return;let s;if (ke(n, "v-cloak"), s = ke(n, "v-if")) return ((e, t, n) => {const s = e.parentElement,r = new Comment("v-if");s.insertBefore(r, e);const i = [{ exp: t, el: e }];let o, c;for (; (o = e.nextElementSibling) && (c = null, "" === ke(o, "v-else") || (c = ke(o, "v-else-if")));) s.removeChild(o), i.push({ exp: c, el: o });const l = e.nextSibling;let f;s.removeChild(e);let u = -1;const a = () => {f && (s.insertBefore(r, f.el), f.remove(), f = void 0);};return n.effect(() => {for (let e = 0; e < i.length; e++) {const { exp: t, el: o } = i[e];if (!t || We(n.scope, t)) return void (e !== u && (a(), f = new it(o, n), f.insert(s, r), s.removeChild(r), u = e));}u = -1, a();}), l;})(n, s, t);if (s = ke(n, "v-for")) return Je(n, s, t);if ((s = ke(n, "v-scope")) || "" === s) {const e = s ? We(t.scope, s) : {};t = st(t, e), e.$template && tt(n, e.$template);}const r = null != ke(n, "v-once");r && (Ue = !0), (s = ke(n, "ref")) && et(n, Ze, `"${s}"`, t), Xe(n, t);const i = [];for (const { name: e, value: o } of [...n.attributes]) De.test(e) && "v-cloak" !== e && ("v-model" === e ? i.unshift([e, o]) : "@" === e[0] || /^v-on\b/.test(e) ? i.push([e, o]) : Ye(n, e, o, t));for (const [e, o] of i) Ye(n, e, o, t);r && (Ue = !1);} else if (3 === n) {const n = e.data;if (n.includes(t.delimiters[0])) {let s,r = [],i = 0;for (; s = t.delimitersRE.exec(n);) {const e = n.slice(i, s.index);e && r.push(JSON.stringify(e)), r.push(`$s(${s[1]})`), i = s.index + s[0].length;}i < n.length && r.push(JSON.stringify(n.slice(i))), et(e, Re, r.join("+"), t);}} else 11 === n && Xe(e, t);},Xe = (e, t) => {let n = e.firstChild;for (; n;) n = Qe(n, t) || n.nextSibling;},Ye = (e, t, n, s) => {let r, i, o;if (":" === (t = t.replace(Ge, (e, t) => ((o || (o = {}))[t] = !0, "")))[0]) r = xe, i = t.slice(1);else if ("@" === t[0]) r = Ae, i = t.slice(1);else {const e = t.indexOf(":"),n = e > 0 ? t.slice(2, e) : t.slice(2);r = Fe[n] || s.dirs[n], i = e > 0 ? t.slice(e + 1) : void 0;}r && (r === xe && "ref" === i && (r = Ze), et(e, r, n, s, i, o), e.removeAttribute(t));},et = (e, t, n, s, r, i) => {const o = t({ el: e, get: (t = n) => We(s.scope, t, e), effect: s.effect, ctx: s, exp: n, arg: r, modifiers: i });o && s.cleanups.push(o);},tt = (e, t) => {if ("#" !== t[0]) e.innerHTML = t;else {const n = document.querySelector(t);e.appendChild(n.content.cloneNode(!0));}},nt = e => {const t = { ...e, scope: e ? e.scope : fe({}), dirs: e ? e.dirs : {}, effects: [], blocks: [], cleanups: [], delimiters: ["{{", "}}"], delimitersRE: /\{\{([^]+?)\}\}/g, effect: e => {if (Ue) return ve(e), e;const n = function (e, t) {e.effect && (e = e.effect.fn);const n = new I(e);t && (u(n, t), t.scope && j(n, t.scope)), t && t.lazy || n.run();const s = n.run.bind(n);return s.effect = n, s;}(e, { scheduler: () => ve(n) });return t.effects.push(n), n;} };return t;},st = (e, t = {}) => {const n = e.scope,s = Object.create(n);Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)), s.$refs = Object.create(n.$refs);const r = fe(new Proxy(s, { set: (e, t, s, i) => i !== r || e.hasOwnProperty(t) ? Reflect.set(e, t, s, i) : Reflect.set(n, t, s) }));return rt(r), { ...e, scope: r };},rt = e => {for (const t of Object.keys(e)) "function" == typeof e[t] && (e[t] = e[t].bind(e));};class it {constructor(e, n, s = !1) {t(this, "template"), t(this, "ctx"), t(this, "key"), t(this, "parentCtx"), t(this, "isFragment"), t(this, "start"), t(this, "end"), this.isFragment = e instanceof HTMLTemplateElement, s ? this.template = e : this.isFragment ? this.template = e.content.cloneNode(!0) : this.template = e.cloneNode(!0), s ? this.ctx = n : (this.parentCtx = n, n.blocks.push(this), this.ctx = nt(n)), Qe(this.template, this.ctx);}get el() {return this.start || this.template;}insert(e, t = null) {if (this.isFragment) {if (this.start) {let n,s = this.start;for (; s && (n = s.nextSibling, e.insertBefore(s, t), s !== this.end);) s = n;} else this.start = new Text(""), this.end = new Text(""), e.insertBefore(this.end, t), e.insertBefore(this.start, this.end), e.insertBefore(this.template, this.end);} else e.insertBefore(this.template, t);}remove() {if (this.parentCtx && ((e, t) => {const n = e.indexOf(t);n > -1 && e.splice(n, 1);})(this.parentCtx.blocks, this), this.start) {const e = this.start.parentNode;let t,n = this.start;for (; n && (t = n.nextSibling, e.removeChild(n), n !== this.end);) n = t;} else this.template.parentNode.removeChild(this.template);this.teardown();}teardown() {this.ctx.blocks.forEach(e => {e.teardown();}), this.ctx.effects.forEach(F), this.ctx.cleanups.forEach(e => e());}}const ot = e => e.replace(/[-.*+?^${}()|[\]\/\\]/g, "\\$&"),ct = e => {const t = nt();if (e && (t.scope = fe(e), rt(t.scope), e.$delimiters)) {const [n, s] = t.delimiters = e.$delimiters;t.delimitersRE = new RegExp(ot(n) + "([^]+?)" + ot(s), "g");}let n;return t.scope.$s = Ce, t.scope.$nextTick = ge, t.scope.$refs = Object.create(null), { directive(e, n) {return n ? (t.dirs[e] = n, this) : t.dirs[e];}, mount(e) {if ("string" == typeof e && !(e = document.querySelector(e))) return;let s;return s = (e = e || document.documentElement).hasAttribute("v-scope") ? [e] : [...e.querySelectorAll("[v-scope]")].filter(e => !e.matches("[v-scope] [v-scope]")), s.length || (s = [e]), n = s.map(e => new it(e, t, !0)), this;}, unmount() {n.forEach(e => e.teardown());} };};let lt;(lt = document.currentScript) && lt.hasAttribute("init") && ct().mount();export { ct as createApp, ge as nextTick, fe as reactive };